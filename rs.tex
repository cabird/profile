\documentclass[10pt]{article}
% Seems like it does not support 9pt and less. Anyways I should stick to 10pt.
%\documentclass[a4paper, 9pt]{article}
\topmargin-2.0cm

\usepackage{fancyhdr}
\usepackage{pagecounting}
\usepackage[dvips]{color}

% Color Information from - http://www-h.eng.cam.ac.uk/help/tpl/textprocessing/latex_advanced/node13.html

% NEW COMMAND
% marginsize{left}{right}{top}{bottom}:
%\marginsize{3cm}{2cm}{1cm}{1cm}
%\marginsize{0.85in}{0.85in}{0.625in}{0.625in}

\advance\oddsidemargin-0.65in
%\advance\evensidemargin-1.5cm
\textheight9.2in
\textwidth6.75in
\newcommand\bb[1]{\mbox{\em #1}}
\def\baselinestretch{1.05}
%\pagestyle{empty}

\newcommand{\hsp}{\hspace*{\parindent}}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
%\definecolor{gray}{rgb}{1.0,1.0,1.0}

\newcommand\Section[1]{\section*{#1}}
\newcommand\Subsection[1]{\subsubsection*{#1}}

\begin{document}
\thispagestyle{fancy}
%\pagenumbering{gobble}
%\fancyhead[location]{text} 
% Leave Left and Right Header empty.
\lhead{}
\rhead{}
%\rhead{\thepage}
\renewcommand{\headrulewidth}{0pt} 
\renewcommand{\footrulewidth}{0pt} 
\fancyfoot[C]{\footnotesize \textcolor{gray}{http://wwwcsif.ucdavis.edu/$\sim$bird/index.html}}

%\pagestyle{myheadings}
%\markboth{Sundar Iyer}{Sundar Iyer}

\pagestyle{fancy}
\lhead{\textcolor{gray}{\it Christian Bird, Research Statement}}
\rhead{\textcolor{gray}{\thepage/\totalpages{}}}
%\rhead{\thepage}
%\renewcommand{\headrulewidth}{0pt} 
%\renewcommand{\footrulewidth}{0pt} 
%\fancyfoot[C]{\footnotesize http://www.stanford.edu/$\sim$sundaes/application} 
%\ref{TotPages}

% This kind of makes 10pt to 9 pt.
\begin{small}

%\vspace*{0.1cm}
\begin{center}
{\LARGE \bf RESEARCH STATEMENT}\\
\vspace*{0.1cm}
{\normalsize Christian Bird (cabird@ucdavis.edu)}
\end{center}
%\vspace*{0.2cm}

%\begin{document}
%\centerline {\Large \bf Research Statement for Sundar Iyer}
%\vspace{0.5cm}

% Write about research interests...
%\footnotemark
%\footnotetext{Check This}

As software projects grow in terms of size and complexity, so do the teams of
people that contribute to it in any of a myriad of ways.  As this phenomenon
becomes more pronounced, the social aspects of software development become more
prominent and play important roles.  However, as Conway proposed in 1968, I
believe that the social aspects of software engineering are intimately tied
with the technical artifact itself.  My research interests lie largely in the
relationship between characteristics of software (e.g. architecture, language,
process used, domain) and the coordination and communication that happens in the
teams that develop and maintain it.

I am also largely interested using rigorous empirical methods to evaluate
questions about software engineering processes.  Unfortunately, the state
of quantitative analysis in software engineering lags tremendously behind
other fields such as econometrics, organizational behavior, and sociology.
In the best case, misapplied empirical methods leave research questions
unanswered, while in the worst case they lead to wrong answers which are believed
to be empirically correct upon which further research may rest.  Software
companies change their practices and perform self-analysis based on results
of empirical research, thus results that are based on incorrect data or even
over-generalizes results has a very real effect on both researchers and 
practitioners.

\Section{Background and Current Work}

I'm interested in how projects tick.  In order to study software development,
one needs access to project data such as communication, source code change
activity, issue tracking information, etc.  Unfortunately, it is difficult 
and time consuming to obtain this information from commercial entities for
a number of reasons.

Open Source Software (OSS) projects have proliferated wildly over the past
decade.  While the vast majority of OSS projects either fail, or are unable (or
are unintended) to gain a large user and developer base, there are still a
large number of projects whose use, size (in terms of developers and source
code), complexity, and code quality rival their commercial counterparts.  These
select few (though they do still number in the tens to hundreds) such as the
Linux kernel, Apache, Postgres, Python, and Firefox, are worthy of study
because they represent stable codebases developed by large developer teams.
These teams deal with nearly all of the challenges faced by other large
developmen teams: coordination of many developers, changing requirements,
complaints for users, fixing bugs, dealing with maintenance issues, bogged down
by architectural decisions, etc.  Fortunately for many researchers, the data and
meta-data associated with these projects is publicly available, providing
an opportunity for software engineering researchers.

\Subsection{Mining Methods}

My research has focused on techniques for mining data from software projects
and analyzing gathered data to answer questions about software engineering.

The preferred method for communication in most OSS projects is via
developer mailing lists.  This allows all people involved to view
topics under discussion and to jump in when desired.  It also allows
project members to return to a discussion to determine who made project
decisions and why they were made.  As such, the contents of these archived
mailing lists are useful for research.

There are issues in mining such data, however.  Unlike commercial settings most
contributors use multiple email addresses when participating in projects, which
can lead one to attribute messages to unique identities even though they were
sent by the same person.  My research introduced this problem and presented the
first mining techniques for dealing with this email aliasing issue and also
related issues in linking mailing list personalities with accounts source code
management (SCM) systems.  I used this to create and examine of the
first mined developer social networks.  
We mined data from a number of projects and used social network analysis
to quantify the behaviour and ``importance'' of OSS project members.
We found that there is a strong link between communication behavior and
development activity for project developers, and that there is less of a
relationship for project documenters.  Thus, the need for communication and
coordination to accomplish one's task is strongly affected by the role that a
participant plays in a project.  This has strong implications for...

As most OSS projects rely on volunteer labor, the process by which work gifts
are accepted by the project is important (lame word....).  Volunteer
contributions often come in the form of ``patches'' which are reified changes
to source code that can be posted to a mailing list or otherwise delivered to
the inner circle of developers who have write access to the source code.  I
introduced a method for both identifying such contributions to OSS projects and
detecting if they were accepted into the official code base for the project
even if minor modifications were made to the patch (which they often are).  We
used this data in conjunction with data gathered previously to answer the
question ``What does it take to gain admittance to the inner circle of
committing developers?'' The surprising answer for all of the projects studied,
which we deliberately chose to cover diverse domains and governance styles, was
that the likelihood is not only dependent on social status and contrbutions
made, but also non-monotonically linked with time that a participant has
spent with the project.

I have also studied an emerging trend in OSS development, distributed version
control, and it's effect on coordination and process in projects.  As the main
channel by which changes to software are stored and conveyed, the version
control system is tied to the process that a software team used.  We pioneered
mining data from distributed source control and published a guide listing the
opportunities as well as hurdles associated with mining data from distributed
SCM's along with solutions to such problems.

From my experience doing research, I have found that relying on data in a
purely quantitative fashion can lead to wrong conclusions or at best, hides
opportunities to understand it better.  We therefore used a quantitative
approach to determine why so many OSS projects were switching from a
centralized SCM system to a distributed one.  By interviewing developers from a
number of projects and identifying the differences in development activity
prior to and following their switch, we were able to identify the benefits that
projects enjoyed, or hope to enjoy by such a move.  Many of these benefits came
down to affecting how developers were able to coordinate their activities
and share their changes.

\Subsection{Communication and Coordination}


I have performed a number of empirical studies on communication and coordination
in software engineering.

While many have studied the globally distributed software development, I
performed the first results that examined the effect of distributed development
on post-release failures, one of the most important characteristics of
software.  My research on the development of Windows Vista showed that while
there are difficulties inherent in globally distributed software development,
such as cultural differences and lack of easy synchronous communicating, the
difference in software quality between components that are developed in one
location and those that are spread abroad is nearly all attributable to the
size of the development team.  Put simply, a component that is developed by twenty
people in one buildng and twenty people in scattered across the globe have the
same number of post-release failures.

One of the problems with any case study (and one often overlooked by the
authors of such a work) is that it is unclear how well the results generalize
and how much they are affected by any number of variables.  In an effort to
understand distributed development better, I have also examined distributed
development in the context of other projects, some open source, and some which
represent a hybrid process which incorporates open source style development.
The results of my analysis have led to the following conclusion:

When projects have a non-trivial number of distributed components, there is
little difference in quality between distributed and collocated components.
However, when only a few of the components are distributed, such components
suffer from a software process in which the effects of distribtued development
are not taken into account and have many more post release bugs.  The
implications are clear, a company cannot move from a a collocated development
style to distributed development without modifying processes accordingly.
However, the move \textbf{can} be made with little effect on code quality.


\Subsection{Data Quality}

I am also interested in the quality of data that is used in empirical software
engineering.  Corrupted or incomplete data can lead to incorrect results which
can affect both future research and practitioners who may modify their
practices according to them.  To demonstrate this problem, we gathered bug data
from many projects, identified bias in the data, and showed how this bias can
lead to false conclusions and biased bug location predictions.

BugCache is an award winning bug prediction technique based on tracking the
locality of bugs and their fixes.  We showed that the bug databases for many
OSS projects are incomplete, in that many bugs that are marked as fixed cannot
be accurately ``linked'' to the correcting change in the project SCM.  Through
the use of rigorous statistical methods we showed that such links are missing
in a way that is heavily biased in almost all projects and that when used on
such biased data, BugCache only predicts similarly biased bugs.  One vitally
important dimensions of bias in bug data is severity.  More severe bugs are
less likely to be linked to their changes.  Thus, a bug prediction method will
tend to predict less severe bugs much more accurately than more severe ones,
which is likely the exact opposite of what a practitioner would use it for.

I believe that it is possible to overcome this problem, however, and am
currently working on ways to combat it.  I have developed tools for efficiently
working with both source code and bug data and have used them with project
developers to recreate missing links which can then be used to determine both
\textbf{why} data was missing in the first palce and \textbf{how} to deal with
it's absence after the fact.


\Section{Social Empirical Software Engineering -- A Research Agenda}


Games (more than developers... TONS of content)

Web Applications (many tiers)

Noisy Data...

   In the course of my research, I have noticed that the overhead (in terms
of size, power and cost) of designing networking components, which give 
performance guarantees is small. 
This is mainly due to two reasons. First, the inherent nature of 
networking makes many of these problems tractable. Second, a number of
hardware advances in Architecture, insights in Algorithms {\it \&} Combinatorics, 
as well as analysis techniques from Probability, {\it \&} Queueing Theory 
aid in the design of elegant and simple solutions.
I envisage the field of {\it Network Architecture} created from the 
ground up, building upon the foundations of a number of fields
including those mentioned above.

In the near future, I am interested in the 
principles involved in the design of basic networking 
components. These include
hardware components (e.g. scalable memories, 
network processor and co-processor architectures) and 
software techniques (e.g. network algorithms, packet processing 
techniques). 
  Simultaneously, I intend to understand how large components, which use
the above building blocks can be architected.
My research will focus on how these basic and large
components can be built in a scalable manner while maintaining 
performance guarantees. 
In particular, examples of large components that I have a keen
interest in are switches 
(e.g. packet and circuit switches, multi-service routers etc.), 
security devices (e.g. firewalls and intrusion detection 
systems), network maintenance devices (e.g. measurement,
management infrastructure) and application aware devices
(e.g. web server load balancers, proxies) etc. 

In the future, though performance and scalability will remain key,
I also intend to look at issues such as {\it fault tolerance, graceful degradation,
reliability and uptime} of networking systems, which will become more relevant. 
I also believe that as systems become increasingly large and 
inter-dependent, {\it simplicity in design and component 
re-use} will be major factors.
Parallelism can play a key role here.
Indeed, many of our proposed solutions, involve component re-use and 
parallelism, which can aid and abet the above.


My research will involve a good mix of futuristic and present 
day research. 
One part of my work will focus on fundamentally different proposals and
radical solutions. As an example
--- can we finally achieve real-time streaming over the Internet,
assuming that the various network components give performance guarantees?
In contrast, I intend to devote the other part of my work 
on practical systems, which have immediate relevance and impact in Industry.
I intend to work closely with a number of
researchers in related fields. Similarly, I intend to
collaborate with Industry in understanding and developing solutions
for practical problems. I believe my past experience of research
work done jointly with a number of colleagues as well as my prior record
of participation with Industry will help me achieve this. 
I am excited at the
prospect of learning, contributing, giving shape and making an
impact in this upcoming and challenging field.  


\vspace{0.5cm}
%\begin{flushright}
%Sundar Iyer
%\end{flushright}

\end{small}
%\newpage

\begin{footnotesize}

\bibliographystyle{IEEEtran}
\bibliography{bird}

\end{footnotesize}

\end{document}

