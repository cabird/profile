\documentclass[10pt]{article}
% Seems like it does not support 9pt and less. Anyways I should stick to 10pt.
%\documentclass[a4paper, 9pt]{article}
\topmargin-2.0cm

\usepackage{fancyhdr}
\usepackage{pagecounting}
\usepackage[dvips]{color}

% Color Information from - http://www-h.eng.cam.ac.uk/help/tpl/textprocessing/latex_advanced/node13.html

% NEW COMMAND
% marginsize{left}{right}{top}{bottom}:
%\marginsize{3cm}{2cm}{1cm}{1cm}
%\marginsize{0.85in}{0.85in}{0.625in}{0.625in}

\advance\oddsidemargin-1in
%\advance\oddsidemargin-0.65in
%\advance\evensidemargin-1.5cm
\textheight9.2in
\textwidth6.5in
\def\baselinestretch{1.05}
%\pagestyle{empty}

\newcommand{\hsp}{\hspace*{\parindent}}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
%\definecolor{gray}{rgb}{1.0,1.0,1.0}

\newcommand\Section[1]{\subsubsection*{\large #1}}
\newcommand\Subsection[1]{\subsubsection*{\small #1}}

\begin{document}
\thispagestyle{fancy}
%\pagenumbering{gobble}
%\fancyhead[location]{text} 
% Leave Left and Right Header empty.
\lhead{}
\rhead{}
%\rhead{\thepage}
\renewcommand{\headrulewidth}{0pt} 
\renewcommand{\footrulewidth}{0pt} 
%\fancyfoot[C]{\footnotesize \textcolor{gray}{http://wwwcsif.ucdavis.edu/$\sim$bird/index.html}}

%\pagestyle{myheadings}
%\markboth{Sundar Iyer}{Sundar Iyer}

\pagestyle{fancy}
%\lhead{\textcolor{gray}{\it Christian Bird, Research Statement}}
%\rhead{\textcolor{gray}{\thepage/\totalpages{}}}
%\rhead{\thepage}
%\renewcommand{\headrulewidth}{0pt} 
%\renewcommand{\footrulewidth}{0pt} 
%\fancyfoot[C]{\footnotesize http://www.stanford.edu/$\sim$sundaes/application} 
%\ref{TotPages}

% This kind of makes 10pt to 9 pt.
\begin{small}

%\vspace*{0.1cm}
\begin{center}
{\LARGE \bf Research Statement}\\
\vspace*{0.2cm}
{\large Christian Bird}\\
\vspace*{0cm}
\texttt{\normalsize cabird@ucdavis.edu}
\end{center}
%\vspace*{0.2cm}

%\begin{document}
%\centerline {\Large \bf Research Statement for Sundar Iyer}
%\vspace{0.5cm}

% Write about research interests...
%\footnotemark
%\footnotetext{Check This}

As software projects grow in terms of size and complexity, so do the teams of
people that contribute to it in any of a myriad of ways.  As this phenomenon
becomes more pronounced, the social aspects of software development become more
prominent and play important roles.  However, as Conway proposed in 1968, I
believe that the social aspects of software engineering are intimately tied
with the technical artifact itself.  My research interests lie largely in the
relationship between characteristics of software (e.g. architecture, language,
process used, domain) and the coordination and communication in the
teams that develop and maintain it.

I am also interested in the use of rigorous empirical methods to evaluate
questions about software engineering processes.  Unfortunately, the state
of quantitative analysis in software engineering lags tremendously behind
other fields such as econometrics, organizational behavior, and sociology.
In the best case, misapplied empirical methods leave research questions
unanswered, while in the worst case they lead to wrong answers which are believed
to be empirically correct, upon which further research may rest.  Software
companies change their practices and perform self-analysis based on results
of such research; results that are based on incorrect data or that are
over-generalized have a very real effect on both researchers and 
practitioners.

\Section{Background and Current Work}

In order to study software development, one needs access to project data such
as communication, source code change activity, issue tracking information,
organizational data, and geographical locations.  

Open Source Software (OSS) projects have proliferated wildly over the past
decade.  While the vast majority of OSS projects either fail, or are unable (or
are unintended) to gain a large user and developer base, there are still a
large number of projects whose use, size (in terms of both developers and
source code), complexity, and code quality rival their commercial
counterparts.  These select few such as the Linux kernel, Apache, Postgres,
Python, and Firefox, are worthy of study because they represent stable
codebases developed by large developer teams that deal with many of the same
challenges faced by other large development teams.  Fortunately the
data and meta-data associated with these projects is publicly available,
providing an exciting opportunity for researcher.

\Subsection{Mining Methods}

My research has focused on techniques for mining data from software projects
and then analyzing this data to answer questions about software engineering.  I
have pioneered a number of mining techniques which have been successful in
obtaining data needed for my analysis and have also been adopted by other researchers.

The preferred method for communication in most OSS projects is via developer
mailing lists.  This allows all people involved to view topics under discussion
and to participate when desired.  As such, the contents of these archived
mailing lists represent the discussion history of a project and are useful for
research.
There are issues in mining such data, however.  Unlike commercial settings,
most contributors use multiple email addresses when participating in projects,
which can lead one to attribute messages to many unique identities even though
they were sent by the same person.  My research introduced this problem and
presented the first mining techniques for overcoming it, which I used to create
and examine the first mined developer communication social networks.  Attributes of these
networks were used (and found to be statistically significant) in a number of
empirical studies.

Volunteer contributions in OSS often come in the form of ``patches'' which are
reified changes to source code.  I introduced a method for both identifying
such contributions and detecting if they were accepted even in the presence of
minor modifications, a common occurrence.  This data has been instrumental in
examining the contribution acceptance criteria and 
requirements needed for participants to become core project
developers.

I have also studied an emerging trend in OSS development, distributed version
control, and it's effect on coordination and process in projects.  As the main
channel by which changes to software are stored and conveyed, the version
control system constrains the process that a software team uses.  We pioneered
mining data from distributed source control and published a guide listing the
opportunities as well as hurdles associated with mining data from distributed
SCMs along with solutions to such problems.


\Subsection{Communication and Coordination}

The mining of data is only a means to an end.  The goal of such
effort has always been to use the gathered data to learn about how software
projects work.  To that end, I have performed a number of empirical studies
to answer questions about the relationship of social aspects of projects
with the software itself.

We used social network analysis on mined mailing list data from a number of projects 
to quantify the behaviour and ``importance'' of OSS project members.
We found that there is a strong link between communication behavior and
development activity for project developers, and that there is less of a
relationship for project documenters, indicating that the need for communication and
coordination in accomplishing tasks is strongly affected by the role that a
participant plays.

We used both social network data and patch contribution and acceptance data in
conjunction with data gathered previously to answer the question ``What does it
take to become a core OSS project developer?'' The surprising answer for all of
the projects studied, which we deliberately chose to cover diverse domains and
governance styles, was that the likelihood is not only dependent on social
status and contributions made, but also non-monotonically linked with time that
a participant has spent with the project.  Specifically, members need
project-specific expertise and community respect, both of which increase with
time, in addition to commitment, which arguably wanes over time.  We observed
``peak'' time at which participants become project developers.  While these
findings represent OSS, there are clear analogs and implications
for other styles of development.

I have found that relying on data in a
purely quantitative fashion can lead to wrong conclusions or at best, hides
opportunities to understand it better.  Thus, I used a qualitative approach of
interviewing lead developers from OSS
projects that had switched to distributed SCMs in an effort to understand what
benefits they hoped to gain and then performed a quantitive study
assessing hypotheses regarding the effects on developer practices.

While many have studied the globally distributed software development, I
published the first results that examined the effect of distributed development
on post-release failures.  My research on the development of Windows Vista
showed that while there are difficulties inherent in globally distributed
software development, certain processes can mitigate their affects.  I found
that the difference in software quality between components that were developed
in one location and those that were spread abroad was nearly all attributable
to the size of the development team rather than distribution level.  However, one of the problems with any
case study is that it is unclear how well the results generalize and how much
they are affected by any number of variables.   I have therefore examined
distributed development it the the context of other projects that use varying
development styles. The results of my analysis have led to the following
conclusion:

When projects have a non-trivial number of distributed components, there is
little difference in quality between distributed and collocated components.
However, when only a few of pieces are distributed, they suffer from a software
process which relies on collocation, leading to many more post release bugs.  A
company cannot hope to successfully move from a collocated development style to
distributed development without modifying processes accordingly.

I have also explored coordination in contexts other than software engineering.
As an example, I studied academic collaboration by examining patterns of
co-authorship of papers in computer science.  One of the key insights of this
work was that disciplines that are more theoretical, such as theory and
cryptography, have communities which tend to collaborate more freely than
disciplines of practice, which include distributed systems and software
engineering, where we observed highly modular collaboration patterns.


\Subsection{Effects of Data Quality}

I am also interested in the quality of data that is used in empirical software
engineering.  Corrupted or incomplete data can lead to incorrect results which
can affect both future research and practitioners who may modify their
practices according to them.  To demonstrate this problem, we gathered bug data
from many projects, identified bias in the data, and showed how this bias can
lead to false conclusions and biased bug location predictions.
We showed that the bug databases for many
OSS projects are incomplete, in that many bugs that are marked as fixed cannot
be accurately ``linked'' to the correcting change in the project SCM.  Through
the use of rigorous statistical methods we showed that such links are missing
in a way that is heavily biased and that the bug prediction techniques are 
sensitive to such bias, making their utility limited in practice.

I believe that it is possible to overcome this problem, however, and am
currently working on ways to combat it.  I have developed tools for efficiently
working with both source code and bug data and have used them with project
developers to recreate missing links which can then be used to determine both
\textbf{why} data was missing in the first place and \textbf{how} to deal with
it's absence after the fact.

\Section{Future Work}

I believe that the answer to many software engineering questions is in fact
``It depends.'' There is no best software process or best programming
language.  Agile and scrum work quite well for some projects, but won't work for all
of them.  Sometimes adding people to software project actually \textbf{is} the
best decision.  Searching for universal answers to such questions may be
misleading.  There is value in determining what the answers to questions
actually depend on.  I have found, for instance, that when certain processes
are used, software quality \textbf{does not} depend on geographic distribution.
I \textbf{have} found that in both open source and industrial contexts,
patterns of socio-technical relationships are indicative of failure prone
software components.  I plan to investigate what attributes of software
projects affect coordination needs and the relationship of social structure 
with outcomes.

\Subsection{Studying Diverse Domains}

Game development and web applications are areas of software engineering that
remain underrepresented in research.  Yet both of these areas are
growing segments of the software industry in terms of money, talent, and market
share.  Identifying the differences in these domains relative to other
fields helps to understand what software engineering principles and
results are unlikely to hold, while affirming results from prior studies give
evidence that such findings are universal and broadly applicable.

The video game industry represents \$10's of billions annually. However, game
development differs from the development of typical products in some important
ways.

\begin{enumerate}

\item Content - Most games are split into an engine, which represents executable code,
    and data content.  Compared to other software domains, a disproportionately large
    amount of money, time, talent, and space is devoted on content.  
    Many software engineering research techniques, such as
    bug prediction techniques, awareness tools, and recommender systems, use attributes
    of source code.  Thus, these techniques are of limited value
    in a game development context.  I plan to explore the relationship between content
    and code relationships in an effort to devise new
    methods for bug prediction, team member awareness, and expert recommendation.

\item Team Makeup - A sizeable proportion of team members
    are not software developer.  One might well expect that the communication and coordination needs of members
    in content creation and testing roles differ from software developers.  I plan to observe, record, and mine
    interactions, socio-technical relationships, and information 
    needs in order to characterize the differences in these roles
    and correlate them with outcomes, leading 
    to an increased understanding of the dynamics in game development teams.

\item Closed Systems - Though slowly changing, most gaming software runs in a relatively closed
    system.  Console games run on a very restricted set of hardware.  The set of ``installed''
    software is also constrained.  Relative to other applications 
    that are data directed such as web browsers and office applications, 
    the set of data for games is either known in advance or,
    in the case of downloadable content, controlled.
    How do these differences affect the testing needed to assure quality and stability?  

\end{enumerate}

Web applications are becoming more and more complex and prevalent.  The vast
majority of everyday computing tasks can be accomplished via any notebook
equipped with a web browser.  The architecture of these applications often spans a number of
machines from the client to a web server to a back store.  Development of these
applications has many differences from traditional development.

\begin{enumerate}

\item Live Hosting - 
    In stark contrast to traditional development where a relatively static
    product is downloaded and installed on a user's machine, web applications are repeatedly ``deployed''
    whenever they are accessed by a browser.  Many web applications 
    claim to update production code multiple times per week and 
    test new features by observing the effects of enabling them for a subset of their users. 
    This gives development teams greater flexibility in terms of timelines and release cycles. 
    I plan to investigate the opportunities and costs associated with this key difference.

\item Monitoring - Since web applications are hosted on servers, usage of the software
    can be monitored much more closely than traditional applications.  While companies have used limited
    user studies, opt-in data gathering systems, and crash reporting applications, it is difficult
    to determine how an application is being used ``in the field.'' 
    The ability to see what parts of an application are being used, what is causing crashes, and where
    performance degrades has many many benefits.  This data can be used to direct resource allocation and for
    feature planning.  It can also provide rich information about failures such as how many users 
    are being affected and what the contexts of failure are.  

\end{enumerate}


\Subsection{Dealing with Data Quality Issues}

I also plan to investigate methods of dealing with data quality issues.  My
research has succeeded in showing the ways in which poor data can lead to
incorrect or biased results.  The next steps include devising methods for
increasing the quality of data and finding techniques that are as robust to
noisy data as possible.

Part of dealing with poor data comes in determining why the data is not complete
in the first place.  Do developers intentionally leave out linking data when it would
implicate them as the person that originally introduced the bug?  Are there times
in a release cycle when developers are more diligent about keeping records?  Understanding
\textbf{why} data is missing can help in both recovering it and altering existing technques
for analyzing it.

\vspace{0.5cm}
%\begin{flushright}
%Sundar Iyer
%\end{flushright}

\end{small}
%\newpage

\begin{footnotesize}

%\bibliographystyle{IEEEtran}
%\bibliography{bird}

\end{footnotesize}

\end{document}

